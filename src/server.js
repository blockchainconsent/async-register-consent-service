/*
 *
 *
 * (c) Copyright Merative US L.P. and others 2020-2022 
 *
 * SPDX-Licence-Identifier: Apache 2.0
 *
 */
require('newrelic');

const log4js = require('log4js');
const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');
const express = require('express');
const timeout = require('connect-timeout');

const swaggerUI = require('swagger-ui-express');
const health = require('@cloudnative/health-connect');
const swaggerDoc = require('./swagger.json');

const config = require('./config');

const registerRouter = require('./api/routes/register');
const usersRouter = require('./api/routes/users');

const { kafkaService } = require('./api/services/kafkaService');
const { registerChecks } = require('./api/helpers/healthChecker');
const requestTimeout = require('./api/middleware/request-timeout');

const app = express();
const log = require('./api/helpers/logger').getLogger('app');

const port = process.env.PORT || config.app.port;
const httpsEnabled = process.env.ENABLE_HTTPS || process.env.NODE_ENV === 'production' || config.app.httpsEnabled;

// Configure express
app.use(timeout(config.app.requestTimeout));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.disable('x-powered-by');

// Set up requests logging
const requestLog = require('./api/helpers/logger').getLogger('request');

app.use(log4js.connectLogger(requestLog, { level: log4js.levels.DEBUG }));

// Set up request timeout
app.use(requestTimeout);

// Configure routes
app.use('/async-register-consent', swaggerUI.serve, swaggerUI.setup(swaggerDoc));
app.use('/gateway/api/v1/register-consent', registerRouter);
app.use('/gateway/api/v1/login', usersRouter);

// Health check
const healthcheck = new health.HealthChecker();
app.use('/gateway/health', health.HealthEndpoint(healthcheck));
app.use('/gateway/live', health.LivenessEndpoint(healthcheck));
app.use('/ready', health.ReadinessEndpoint(healthcheck));

// Dynamic Scan
app.use('/DomainVerification.html', express.static(path.join(__dirname, 'public', 'root', 'DomainVerification.html')));

app.use((_req, res) => {
  res.status(404).json({
    status: 404,
    message: 'Not Found',
  });
});

// eslint-disable-next-line no-unused-vars
app.use((err, _req, res, next) => {
  log.error(`${err}`);
  res.status(500).json({
    status: 500,
    message: err.message || 'Internal server error',
  });
});

log.info('Starting server');

/*
 * To launch HTTPS server it requires
 * private key (server.key) and certificate (server.crt).
 * For test and local development these files can be generated by openssl tool.
 *
 * openssl genrsa -out key.pem
 * openssl req -new -key key.pem -out csr.pem
 * openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem
 * rm csr.pem
 *
 * openssl genrsa -des3 -out server.key 1024
 * openssl req -new -key server.key -out server.csr
 * cp server.key server.key.org
 * openssl rsa -in server.key.org -out server.key
 * openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
 * rm -rf server.key.org
 * rm -rf server.csr
 */
let server;
if (httpsEnabled) {
  log.info('HTTPS enabled');

  const keyfile = path.join(__dirname, 'ssl', 'tls.key');
  const certFile = path.join(__dirname, 'ssl', 'tls.crt');

  const httpsOptions = {
    key: fs.readFileSync(keyfile),
    cert: fs.readFileSync(certFile),
  };

  server = https.createServer(httpsOptions, app);
  server.listen(port, async () => {
    log.info(`HTTPS server started on port ${port}`);
    registerChecks(health, healthcheck);
    await kafkaService.connectAdmin();
    await kafkaService.connect();
  });
  // All inactive connections are terminated by the ALB, by setting this a few seconds higher than the ALB idle timeout
  server.keepAliveTimeout = config.app.serverKeepAliveTimeout;
  // The headersTimeout is set higher than the keepAliveTimeout due to this nodejs regression bug: https://github.com/nodejs/node/issues/27363
  server.headersTimeout = config.app.serverHeadersTimeout;
} else {
  server = http.createServer(app);
  server.listen(port, async () => {
    log.info(`Server up on port: ${port}`);
    registerChecks(health, healthcheck);
    await kafkaService.connectAdmin();
    await kafkaService.connect();
  });
  // All inactive connections are terminated by the ALB, by setting this a few seconds higher than the ALB idle timeout
  server.keepAliveTimeout = config.app.serverKeepAliveTimeout;
  // The headersTimeout is set higher than the keepAliveTimeout due to this nodejs regression bug: https://github.com/nodejs/node/issues/27363
  server.headersTimeout = config.app.serverHeadersTimeout;
}

// Handle shutdown signals. Safely shutting down processes and closing connections
const signalTraps = ['SIGTERM', 'SIGINT', 'SIGUSR2'];
signalTraps.forEach((type) => {
  process.once(type, () => {
    log.info(`Received kill '${type}' signal, shutting down gracefully`);
    server.close(async (err) => {
      await kafkaService.disconnectAdmin();
      await kafkaService.disconnect();
      if (err) {
        log.error('An error while shutting down:', err);
        // eslint-disable-next-line no-process-exit
        process.exit(1);
      }
      // eslint-disable-next-line no-process-exit
      process.exit(0);
    });
  });
});

module.exports = server;
